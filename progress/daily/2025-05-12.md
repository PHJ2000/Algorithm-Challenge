# 📅 2025-05-12 문제 풀이 로그

## ✅ 푼 문제

- [x] 1987 - 알파벳 (백준)  
  → (0, 0)에서 시작하여 상하좌우로 인접한 칸을 이동하며  
     이미 방문한 알파벳은 다시 방문할 수 없는 조건에서  
     말이 지날 수 있는 최대 칸 수를 구하는 문제  
  → DFS + 백트래킹 알고리즘 사용  
  → 방문 알파벳 여부는 26비트 정수(비트마스크)로 관리하여 성능 최적화  
  → 현재 칸에서 이동 가능한 모든 방향으로 분기하며, 최대 깊이를 갱신  
  → PyPy3 환경에서 제출해야 시간초과 없이 통과됨

## 🧠 짧은 회고

- 단순 DFS 백트래킹이지만, 파이썬에서는 set이나 문자열 누적 방식은 시간초과 발생  
- 비트마스킹을 활용한 방문 처리로 연산을 정수 연산으로 최적화할 수 있었음  
- 재귀 호출이 많은 문제는 PyPy3로 제출해야 통과 가능하다는 점을 실전에서 체감함  
- 알파벳 방문 여부를 비트 연산으로 처리하는 아이디어는 다른 문제에서도 재사용 가능하므로 확실히 익혀두어야 함
